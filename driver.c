#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include "lexer.h"
#include "buffer.h"
#include "FirstAndFollow.h"
#include "parserDef.h"
#include "parser.h"
#include "globalDef.h"
#include <time.h>
#include <stdlib.h>

#define CLOCKS_PER_SEC 1000000

int main(int argc, char *argv[]) {
    // The first argument is the file name
    if (argc !=3 ) {
        printf("Incorrect num of ARGUMENTS. Usage: %s <filename> <parseOutputFileName>\n", argv[0]);
        return 1;
    }

    char* treeFile;

    //user gives custom name for parsetree file
    treeFile = argv[2];

    twinBuffer *buffer;
    FILE *fp;

    while (1) {
        printf("CS F303 Compiler\n");
        printf("Enter a command: ");
        printf("0 - quit\n");
        printf("1 - removal of comments and print to console\n");
        printf("2 - print token list to console\n");
        printf("3 - parse the source code to generate parse tree\n");
        printf("4 - find parsing time\n");

        int option;

        scanf("%d", &option);

        switch (option)
        {
        case 0:
            
            return 0;

        case 1:
            
            if(removeComments(argv[1],CLEAN_FILE) < 0) {
                printf("Comments could not be removed.\n");
            } else {
                printf("Comments removed successfully, clean code stored in \"%s\".\n",CLEAN_FILE);
            }

            break;
        case 2:
            
            buffer = init_lexer(argv[1]);
            if(buffer == NULL) {
                printf("Lexer could not be initialised for \"%s\".\n",argv[1]);
                break;
            }
            
            token receivedToken;
            
            do {
                receivedToken = get_next_token(buffer);
                print_token(stdout, receivedToken);
            } while (receivedToken.type != TK_EOF);
            
            break;
        case 3:

            //load key map, intiate twin buffer and wait for request of a token
            buffer = init_lexer(argv[1]);
            if(buffer == NULL) {
                printf("Lexer could not be initialised for \"%s\".\n",argv[1]);
                break;
            }

            printf("\nLexer successfully initialised and connected to buffer stream, keywordMap.\n");

            //compute first and follow sets for each non terminal in the grammar and store the information in NonTerms[MAX_NT]
            //First and Follow sets.txt files are generated by the writeFirstsToFile() and writeFollowsToFile() functions
            FirstAndFollowElement* FirstAndFollowAll = computeFirstAndFollowSets(GRAMMAR_FILE);
            printf("\nFirst and follow sets calculated\n");

            //populate the grammar rules from the file -> grammarRules 
            populateRules();
            printf("\nRules populated\n");
            
            printf("\nnumNonTerminals: %d\n",numNonTerminals);
            printf("\nParser initialised, creating Parse Table.\n");

            //fill up the parse table 
            createParseTable(FirstAndFollowAll, parseTable);

            printf("\nParse table generated.\n");
            //print and store the parse table in a .csv file
            printParseTableToFile();

            printf("\nParse Table printed in \"%s\", Suggested for viewing in (Excel/LibreOffice/Pages).\n",PARSE_TABLE_FILE);

            ParseTreeNode* root =  parseInputSourceCode(buffer);
            printf("\nParse tree generated.\n");

            if(printParseTree(root,treeFile) == -1) {
                printf("\nCould not print the parse tree.\n");
            } else {
                printf("\nSuccessfully printed the parse tree in %s.\n\n\n",treeFile);
            }
            break;
        case 4: 
        {
            clock_t startTime, endTime;

            dou0ble total_CPU_time, total_CPU_time_in_seconds;

            startTime = clock();

            //load key map, intiate twin buffer and wait for request of a token
            buffer = init_lexer(argv[1]);
            if(buffer == NULL) {
                break;
            }

            //compute first and follow sets for each non terminal in the grammar and store the information in NonTerms[MAX_NT]
            //First and Follow sets.txt files are generated by the writeFirstsToFile() and writeFollowsToFile() functions
            FirstAndFollowAll = computeFirstAndFollowSets(GRAMMAR_FILE);

            //populate the grammar rules from the file -> grammarRules 
            populateRules();
            
            //fill up the parse table 
            createParseTable(FirstAndFollowAll, parseTable);

            //print and store the parse table in a .csv file
            printParseTableToFile();

            root =  parseInputSourceCode(buffer);

            if(printParseTree(root,treeFile) == -1) {
                printf("\nCould not print the parse tree.\n");
            } else {
                printf("\nSuccessfully printed the parse tree in %s.\n\n\n",treeFile);
            }

            endTime = clock();

            total_CPU_time = (double) (endTime - startTime);

            total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

            printf("Total time taken for parsing the file = %f.\n\n",total_CPU_time_in_seconds);

            break;
        }
        default:
            break;
        }
    }
    return 0;
}