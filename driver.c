#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include "lexer.h"
#include "buffer.h"
#include "FirstAndFollow.h"
#include "parserDef.h"
#include "parser.h"


int main(int argc, char *argv[]) {
    // The first argument is the file name
    if (argc < 2) {
        printf("TOO FEW ARGUMENTS. Usage: %s <filename> OR %s <filename> <parseOutputFileName>\n", argv[0], argv[0]);
        return 1;
    }

    if (argc > 3) {
        printf("TOO MANY ARGUMENTS. Usage: %s <filename> OR  %s <filename> <parseOutputFileName>\n", argv[0], argv[0]);
        return 1;
    }

    char* treeFile;

    //user gives custom name for parsetree file
    if(argc == 3) {
        treeFile = argv[1];
    } else {
        strcpy(treeFile,TREE_FILE);
    }

    twinBuffer *buffer;
    FILE *fp;

    while (1) {
        printf("CS F303 Compiler\n");
        printf("Enter a command: ");
        printf("0 - quit\n");
        printf("1 - removal of comments and print to console\n");
        printf("2 - print token list to console\n");
        printf("3 - parse the source code to generate parse tree\n");

        int option;

        scanf("%d", &option);

        switch (option)
        {
        case 0:
            
            return 0;

        case 1:
            
            if(removeComments(argv[1],CLEAN_FILE) < 0) {
                printf("Comments could not be removed.\n");
            } else {
                printf("Comments removed successfully, clean code stored in \"%s\".\n",CLEAN_FILE);
            }

            break;
        case 2:
            
            buffer = init_lexer(argv[1]);
            if(buffer == NULL) {
                printf("Lexer could not be initialised for \"%s\".\n",argv[1]);
                break;
            }
            
            token receivedToken;
            
            do {
                receivedToken = get_next_token(buffer);
                print_token(stdout, receivedToken);
            } while (receivedToken.type != TK_EOF);
            
            break;
        case 3:

            //load key map, intiate twin buffer and wait for request of a token
            buffer = init_lexer(argv[1]);
            if(buffer == NULL) {
                printf("Lexer could not be initialised for \"%s\".\n",argv[1]);
                break;
            }

            //compute first and follow sets for each non terminal in the grammar and store the information in NonTerms[MAX_NT]
            //First and Follow sets.txt files are generated by the writeFirstsToFile() and writeFollowsToFile() functions
            FirstAndFollowElement* FirstAndFollowAll = computeFirstAndFollowSets(GRAMMAR_FILE);

            //populate the grammar rules from the file -> grammarRules 
            populateRules();

            //fill up the parse table 
            createParseTable(FirstAndFollowAll, parseTable);

            //print and store the parse table in a .csv file
            printParseTableToFile();

            // ParseTreeNode* root =  parseInputSourceCode();

            // if(printParseTree(root,treeFile) == -1) {
            //     printf("Could not print the parse tree.\n");
            // } else {
            //     printf("Successfully printed the parse tree in %s.\n",treeFile);
            // }

            break;
        default:
            break;
        }
    }
    return 0;
}